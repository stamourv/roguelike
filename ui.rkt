#lang racket

(require (only-in srfi/1 iota))
(require "utilities/class.rkt"
         "utilities/grid.rkt"
         "utilities/cell.rkt"
         "utilities/floor-utils.rkt"
         "utilities/terminal.rkt")
(require "common.rkt"
         "character.rkt"
         "player.rkt"
         "scheduler.rkt"
         "objects.rkt"
         "visibility.rkt"
         "combat.rkt"
         "ui-utils.rkt")

(define-method (turn (p struct:player-character) reschedule?)
  (if (and (<= (character-hp player) 0)
	   (not (unbox god-mode?))) ; for debugging
      (begin (display "You die.\n")
	     (quit))
      (begin
	;; if we don't move, we can get multiple attacks (if we have more
	;; than one attack). these "attacks" can also be used to drink
	;; potions or anything else apart from moving. moving stops the
	;; sequence of attacks (so the last "attack" could be a move)
	;; TODO an interesting variant would be to move a certain amount of
        ;;  times, and then only be able to attack, and attack the right
        ;;  number of times, then start the cycle again. would help to display
        ;;  these numbers to the player
	;; TODO would be nice to have both a move action and an attack, but to
        ;;  be able to do a full attack only if we didn't move
	(let ((pos (character-pos player))
	      (bab (character-base-attack-bonus player))) ; to check if we moved
	  (let loop ((n            (character-nb-attacks player))
		     (attack-bonus bab))
	    (when (and (> n 0) (equal? (character-pos player) pos))
		(set-character-current-attack-bonus! player attack-bonus)
                ;; if we didn't move, we can keep attacking
                ;; TODO handle other full-turn actions
                (when (not (eq? (read-command) 'move))
                  (loop (- n 1) (- attack-bonus 5))))))
        ;; TODO call-next-method, especially with multiple attack handling
	(when reschedule? (reschedule player)))))


(define (read-command)
  ;; TODO define all this inside a macro, so that a description can be
  ;;  included with the commands ? or keep 2 separate lists ? or just a
  ;;  lookup list of commands, functions, and doc ? yeah, probably that
  ;;  last one, BUT how to have entries for the movement arrows ?
  (update-visibility)
  (show-state)

  (let* ((pos   (copy-point (character-pos player)))
         (grid  (floor-map (character-floor player)))
         (x     (point-x pos))
         (y     (point-y pos))
         (char  (read-char)))

    (clear-to-bottom)

    ;; escape. bizarrely unrecognizable with case...
    (if (= (char->integer char) 27)
        ;; movement
        (begin (case (which-direction?)
                 ;; TODO abstract with other arrow reading code below
                 ((up)    (set-point-x! pos (- x 1)))
                 ((down)  (set-point-x! pos (+ x 1)))
                 ((right) (set-point-y! pos (+ y 1)))
                 ((left)  (set-point-y! pos (- y 1))))
               ;; tries to move to the new position
               ;; if it fails, stay where we were
               (move grid player pos)
               'move)
        (case char
          ;; inventory ;; TODO have all this generated by macros
          ((#\p) (pick-up pos) 'pick-up)
          ((#\d) (cmd-drop)    'cmp-drop)
          ((#\i) (inventory)   'inventory)
          ((#\e) (equip)       'equip)
          ((#\r) (take-off)    'take-off)
          ((#\D) (cmd-drink)   'cmd-drink)

          ((#\o) (cmd-open)     'cmd-open)
          ((#\c) (cmd-close)    'cmd-close)
          ((#\t) (climb-stairs) 'stairs)

          ((#\s) (shoot) 'shoot)

          ;; help
          ((#\?) (show-help)     'show-help)
          ((#\n) (info grid pos) 'info)
          ((#\l) (look grid pos) 'look)

          ;; debugging
          ((#\k) (kill)       'kill) ; insta-kill a monster
          ((#\R) (reveal-map) 'reveal-map)
          ((#\G) (god-mode)   'god-mode)
          ((#\:) (console)    'console)

          ((#\space) (display "Nothing happens.\n") 'noop)
          ((#\q)     (quit)                         'quit)
          (else      (invalid-command)              'invalid)))))
;; TODO have a README with all that...


;; for debugging
(define (reveal-map)
  (let ((view (player-view player)))
    (grid-for-each (lambda (p) (grid-set! view p 'visited))
                   view)))
(define (god-mode)
  (reveal-map)
  (set-box! god-mode? #t))


(define (quit)
  (display "\nHall of fame:\n\n") ;; TODO have in a function
  (let* ((name         (string->symbol (character-name player)))
         (xp           (player-character-experience player))
         (level        (character-level player))
         (floor-no     (player-character-floor-no player))
         (current-game (list name xp level floor-no))
         (filename     "hall-of-fame"))
    (define (update-hall-of-fame)
      ;; list of pairs (name . score), sorted by descending order of score
      (let* ((l   (sort (cons current-game
                              (if (file-exists? filename)
                                  (with-input-from-file filename read)
                                  '()))
                        ;; TODO if same score, sort with the other factors
                        > #:key cadr))
             (new (take l (min (length l) 10)))); we keep the 10 best
        (display new (open-output-file filename #:exists 'replace))
        new))
    (let loop ((hall (update-hall-of-fame))
               (highlight? #t))
      (when (not (null? hall))
        (let ((head (car hall)))
          (terminal-print
           (format "~a:\t~a\tlevel ~a\tfloor ~a\n"
                   (car head) (cadr head) (caddr head) (cadddr head))
           #:bg (if (and highlight? (equal? (car hall) current-game))
                    'white
                    'black)
           #:fg (if (and highlight? (equal? (car hall) current-game))
                    'black
                    'white))
          (loop (cdr hall)
                (and highlight? (not (equal? (car hall) current-game))))))))
  (newline)
  (restore-tty)
  (exit))


(define (inventory)
  (cursor-home)
  (clear-to-bottom)
  (display "Equipment:\n")
  (for-each-equipped
   (lambda (obj where)
     (printf "~a~a\n" where (if obj (object-info obj) "")))
   (character-equipment player))
  (printf "\nAC: ~a\n" (get-armor-class player))
  (display "\nInventory:\n")
  (for-each (lambda (o) (printf "~a\n" (object-info o)))
            (player-character-inventory player))
  (let loop ((c #f))
    (case c
      ((#\e) (equip))
      ((#\r) (take-off))
      ((#\d) (cmd-drop))
      ((#\q) #f)
      (else (display "\ne: Equip\nr: Take off\nd: Drop\nq: Cancel\n")
            (loop (read-char)))))
  (clear-to-bottom))
(define (pick-up pos) ;; TODO pos can be useful if we can pick up at a distance
  (let* ((cell    (grid-ref (player-map player) pos))
         (objects (cell-objects cell)))
    (choice objects
            (lambda (object)
              (remove-object cell object)
              (set-player-character-inventory!
               player (cons object (player-character-inventory player))))
            "There is nothing to pick up." "Pick up what?" "Picked up "
            show-state)))
(define (cmd-drop)
  (let ((cell    (grid-ref (player-map player) (character-pos player)))
        (objects (player-character-inventory player)))
    (choice objects
            (lambda (object)
              (set-player-character-inventory! player (remove object objects))
              (add-object cell object))
            "You have nothing to drop." "Drop what?" "Dropped "
            show-state)))
(define (equip)
  (let ((e       (character-equipment player))
        (objects (filter (lambda (x) (equipable-object? x))
                         (player-character-inventory player))))
    (choice objects
            (lambda (object)
              ;; TODO macro?
              (let* ((place (cond ((weapon?     object) 'main-hand)
                                  ((shield?     object) 'off-hand)
                                  ((body-armor? object) 'torso)))
                     (old   ((case place
                               ((main-hand) equipment-main-hand)
                               ((off-hand)  equipment-off-hand)
                               ((torso)     equipment-torso))
                             e)))
                (define (back-in-inventory o)
                  (printf "Put ~a back in inventory.\n" (object-name o))
                  (set-player-character-inventory!
                   player (cons o (player-character-inventory player))))
                (set-player-character-inventory!
                 player (remove object objects))
                ((case place
                   ((main-hand) set-equipment-main-hand!)
                   ((off-hand)  set-equipment-off-hand!)
                   ((torso)     set-equipment-torso!))
                 e object)
                ;; TODO generalize with all non-removable items
                (cond ((and old (not (off-hand-placeholder? old)))
                       (back-in-inventory old))
                      ((two-handed-weapon? old)
                       (set-equipment-off-hand! e #f)) ; remove the placeholder
                      ((off-hand-placeholder? old)
                       ;; we have to remove the two-handed weapon itself
                       (back-in-inventory (equipment-main-hand e))
                       (set-equipment-main-hand! e #f)))
                (when (two-handed-weapon? object)
                  (let ((old-off (equipment-off-hand e)))
                    (when (and old-off (not (off-hand-placeholder? old-off)))
                      (back-in-inventory old-off))
                    (set-equipment-off-hand! e (new-off-hand-placeholder))))))
            "You have nothing to equip." "Equip what?" "Equipped "
            show-state)))
(define (take-off)
  (let* ((e       (character-equipment player))
         (objects (filter (lambda (obj) (and obj (removable? obj)))
                          (map car (equipment->list e)))))
    (choice objects
            (lambda (object)
              (cond ((weapon?     object)
                     (set-equipment-main-hand! e #f)
                     (when (two-handed-weapon? object)
                       ;; remove the placeholder
                       (set-equipment-off-hand! e #f)))
                    ((shield?     object)
                     (set-equipment-off-hand!  e #f))
                    ((body-armor? object)
                     (set-equipment-torso!     e #f)))
              (set-player-character-inventory!
               player (cons object (player-character-inventory player))))
            "You have nothing to take off." "Take off what?" "Took off "
            show-state)))

(define (cmd-drink)
  (let* ((e       (character-equipment player))
         (objects (player-character-inventory player))
         (o       #f))
    (choice objects
            (lambda (object)
              (set! o object)
              (set-player-character-inventory! player (remove object objects)))
            "You have nothing to drink." "Drink what?" "Drank "
            show-state)
    ;; necessary to display the messages in the right order
    (when o (drink o) (attacks-of-opportunity player))))

(define (climb-stairs)
  (let ((cell (grid-ref (player-map player) (character-pos player))))
    (let ((current      (player-character-current-floor player))
          (before       (player-character-floors-before player))
          (after        (player-character-floors-after  player)))
      (cond ((stairs-up? cell)
             (cond ((not (null? before))
                    (let ((new (car before)))
                      (place-player
                       player new
                       #:start-pos (floor-stairs-down
                                    (player-floor-floor new)))
                      (set-player-character-floor-no!
                       player (sub1 (player-character-floor-no player)))
                      (set-player-character-floors-after!
                       player (cons current after))
                      (set-player-character-floors-before!
                       player (cdr before))))
                   (else (display "This would lead to the surface.\n"))))
            ((stairs-down? cell)
             (set-player-character-floor-no!
              player (add1 (player-character-floor-no player)))
             (set-player-character-floors-before! player (cons current before))
             (if (null? after)
                 (place-player player
                               (new-player-floor
                                (player-character-floor-no player)))
                 (begin (place-player player (car after))
                        (set-player-character-floors-after!
                         player (cdr after)))))
            (else (display "There are no stairs here.\n"))))))

(define (cmd-open)  (direction-command "Open"  open))
(define (cmd-close) (direction-command "Close" close))


(define (shoot)
  (let* ((grid    (player-map player))
         (weapon  (equipment-main-hand (character-equipment player)))
         (targets (filter (lambda (m)
                            (and (eq? (grid-ref (player-view player)
                                                (character-pos m))
                                      'visible)
                                 (clear-shot? grid
                                              (character-pos player)
                                              (character-pos m))))
                          (floor-monsters (character-floor player))))
         (n       (length targets)))
    (cond
     ((not (ranged-weapon? weapon))
      (display "I can't shoot with that.\n"))
     ((null? targets)
      (display "There is nothing to shoot.\n"))
     (else
      (let ((grid (let ((grid (grid-copy grid)))
                    (for-each
                     (lambda (m n) ;; TODO like choice, won't scale over 10
                       (grid-set!
                        grid
                        (character-pos m)
                        (new-display-cell
                         (string-ref (number->string (+ n 1)) 0))))
                     targets
                     (iota n))
                    grid)))
        ;; show which monsters are which numbers
        (cursor-home) ;; TODO taken from show-state
        (clear-to-bottom)
        (cursor-notification-head)
        (for-each (lambda (m n)
                    (printf-notification "~a: ~a\n"
                                         (+ n 1) (character-name m)))
                  targets
                  (iota n))
        (newline)
        (printf-notification "q: Cancel\n")
        ;; show the map with the target numbers
        (cursor-home)
        (printf "Floor ~a\n" (player-character-floor-no player))
        (show-grid grid
                   #:print-fun (visibility-show (player-view player)
                                                (player-map  player)))
        ;; choose a target
        (let ((nb (read-number n)))
          (when nb (ranged-attack player (list-ref targets nb)))))))))


(define (kill) ; insta-kill something, for debugging purposes
  (direction-command "Kill"
                     (lambda (grid cell player)
                       (cond ((cell-occupant cell)
                              => (lambda (occ)
                                   (printf "Killed the ~a\n"
                                           (character-name occ))
                                   (remove-monster occ)))
                             (else (display
                                    "There is nothing to kill there.\n"))))))

(define (show-help)
  ;; TODO maybe generate commands with a macro and have help text that can be
  ;;  displayed by help, everything would be automatic
  'TODO)

(define (info grid pos)
  ;; TODO show a message about the location, occupant first (unless player),
  ;;  objects then, finally terrain
  (let ((cell (grid-ref grid pos)))
    (cond ((let ((occ (cell-occupant cell)))
             (and occ (not (player-character? occ)) occ))
           => (lambda (occ) (display (character-name occ))))
          ;;        ((car (cell-objects cell))
          ;;         => (lambda (obj) (display (object-name obj))))
          ;; TODO broken. + add monsters
          (else
           (display "Nothing to see here.")))))
;; TODO describe the terrain, have a description for each type, ideally
;;  define with the type

(define (look grid pos)
  ;; TODO have a moveable cursor, and when enter is pressed, display the info
  ;;  of the location, pos is starting position of the cursor, if final cursor
  ;;  position is outside visibility, say I can't see there
  ;; TODO use the choose-direction command to control the cursor
  (cursor-on)
  ;; TODO maybe just be able to look at immediate squares, and just use
  ;;  direction-command, but we might want to identify something before we
  ;;  get closer (a monster, for example)
  (set-cursor-on-grid grid pos)
  (read-char)
  ;; TODO implement the rest, and it seems that pressing l then an arrow
  ;;  shows some weird text in the background about terminal options
  (cursor-off))


(define (show-state)
  (cursor-notification-head)
  (printf-notification "~a\n" (character-name player))
  (printf-notification "level ~a\n" (character-level player))
  (printf-notification "~a xp pts\n" (player-character-experience player))
  (printf-notification "")
  (when (altered-attr? player 'hp)
    (terminal-colors 'white 'black)) ;; TODO abstract that
  (display (character-hp player))
  (terminal-reset)
  (printf "/~a hp\n" (character-max-hp player))
  
  (printf-notification "AC: ")
  (when (altered-attr? player 'natural-ac)
    (terminal-colors 'white 'black))
  (display (get-armor-class player))
  (terminal-reset)
  (newline)
  
  (printf-notification "str: ")
  (when (altered-attr? player 'str)
    (terminal-colors 'white 'black))
  (display (character-str player))
  (terminal-reset)
  (display "	int: ")
  (when (altered-attr? player 'int)
    (terminal-colors 'white 'black))
  (display (character-int player))
  (terminal-reset)
  (newline)
  
  (printf-notification "dex: ")
  (when (altered-attr? player 'dex)
    (terminal-colors 'white 'black))
  (display (character-dex player))
  (terminal-reset)
  (display "	wis: ")
  (when (altered-attr? player 'wis)
    (terminal-colors 'white 'black))
  (display (character-wis player))
  (terminal-reset)
  (newline)
  
  (printf-notification "con: ")
  (when (altered-attr? player 'con)
    (terminal-colors 'white 'black))
  (display (character-con player))
  (terminal-reset)
  (display "	cha: ")
  (when (altered-attr? player 'cha)
    (terminal-colors 'white 'black))
  (display (character-cha player))
  (terminal-reset)
  (newline)
  
  (cursor-home)
  (clear-line)
  (printf "Floor ~a\n" (player-character-floor-no player))
  (show-grid (player-map player)
	     #:print-fun (visibility-show (player-view player)
                                          (player-map  player))))
