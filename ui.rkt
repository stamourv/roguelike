#lang racket

(require "utilities/class.rkt"
         "utilities/grid.rkt"
         "utilities/cell.rkt"
         "utilities/floor-utils.rkt"
         "utilities/terminal.rkt")
(require "common.rkt"
         "character.rkt"
         "player.rkt"
         "scheduler.rkt"
         "commands.rkt"
         "ui-utils.rkt")

(define-method (turn (p struct:player-character) reschedule?)
  (if (and (<= (character-hp player) 0)
	   (not (unbox god-mode?))) ; for debugging
      (begin (display "You die.\n")
	     (quit))
      (begin
	;; if we don't move, we can get multiple attacks (if we have more
	;; than one attack). these "attacks" can also be used to drink
	;; potions or anything else apart from moving. moving stops the
	;; sequence of attacks (so the last "attack" could be a move)
	;; TODO an interesting variant would be to move a certain amount of
        ;;  times, and then only be able to attack, and attack the right
        ;;  number of times, then start the cycle again. would help to display
        ;;  these numbers to the player
	;; TODO would be nice to have both a move action and an attack, but to
        ;;  be able to do a full attack only if we didn't move
	(let ((pos (character-pos player))
	      (bab (character-base-attack-bonus player))) ; to check if we moved
	  (let loop ((n            (character-nb-attacks player))
		     (attack-bonus bab))
	    (when (and (> n 0) (equal? (character-pos player) pos))
		(set-character-current-attack-bonus! player attack-bonus)
                ;; if we didn't move, we can keep attacking
                ;; TODO handle other full-turn actions
                (update-visibility)
                (show-state)
                (when (not (eq? (read-command) 'move))
                  (loop (- n 1) (- attack-bonus 5))))))
        ;; TODO call-next-method, especially with multiple attack handling
	(when reschedule? (reschedule player)))))


(define (read-command)
  ;; TODO define all this inside a macro, so that a description can be
  ;;  included with the commands ? or keep 2 separate lists ? or just a
  ;;  lookup list of commands, functions, and doc ? yeah, probably that
  ;;  last one, BUT how to have entries for the movement arrows ?
  (let* ((pos   (copy-point (character-pos player)))
         (grid  (floor-map (character-floor player)))
         (x     (point-x pos))
         (y     (point-y pos))
         (char  (read-char)))

    (clear-to-bottom)

    ;; escape. bizarrely unrecognizable with case...
    (if (= (char->integer char) 27)
        ;; movement
        (begin (case (which-direction?)
                 ;; TODO abstract with other arrow reading code below
                 ((up)    (set-point-x! pos (- x 1)))
                 ((down)  (set-point-x! pos (+ x 1)))
                 ((right) (set-point-y! pos (+ y 1)))
                 ((left)  (set-point-y! pos (- y 1))))
               ;; tries to move to the new position
               ;; if it fails, stay where we were
               (move grid player pos)
               'move)
        (case char
          ;; inventory ;; TODO have all this generated by macros
          ((#\p) (pick-up pos) 'pick-up)
          ((#\d) (cmd-drop)    'cmp-drop)
          ((#\i) (inventory)   'inventory)
          ((#\e) (equip)       'equip)
          ((#\r) (take-off)    'take-off)
          ((#\D) (cmd-drink)   'cmd-drink)

          ((#\o) (cmd-open)     'cmd-open)
          ((#\c) (cmd-close)    'cmd-close)
          ((#\t) (climb-stairs) 'stairs)

          ((#\s) (shoot) 'shoot)

          ;; help
          ((#\?) (show-help)     'show-help)
          ((#\n) (info grid pos) 'info)
          ((#\l) (look grid pos) 'look)

          ;; debugging
          ((#\k) (kill)       'kill) ; insta-kill a monster
          ((#\R) (reveal-map) 'reveal-map)
          ((#\G) (god-mode)   'god-mode)
          ((#\:) (console)    'console)

          ((#\space) (display "Nothing happens.\n") 'noop)
          ((#\q)     (quit)                         'quit)
          (else      (invalid-command)              'invalid)))))
;; TODO have a README with all that...


(define (quit)
  (display "\nHall of fame:\n\n") ;; TODO have in a function
  (let* ((name         (string->symbol (character-name player)))
         (xp           (player-character-experience player))
         (level        (character-level player))
         (floor-no     (player-character-floor-no player))
         (current-game (list name xp level floor-no))
         (filename     "hall-of-fame"))
    (define (update-hall-of-fame)
      ;; list of pairs (name . score), sorted by descending order of score
      (let* ((l   (sort (cons current-game
                              (if (file-exists? filename)
                                  (with-input-from-file filename read)
                                  '()))
                        ;; TODO if same score, sort with the other factors
                        > #:key cadr))
             (new (take l (min (length l) 10)))); we keep the 10 best
        (display new (open-output-file filename #:exists 'replace))
        new))
    (let loop ((hall (update-hall-of-fame))
               (highlight? #t))
      (when (not (null? hall))
        (let ((head (car hall)))
          (terminal-print
           (format "~a:\t~a\tlevel ~a\tfloor ~a\n"
                   (car head) (cadr head) (caddr head) (cadddr head))
           #:bg (if (and highlight? (equal? (car hall) current-game))
                    'white
                    'black)
           #:fg (if (and highlight? (equal? (car hall) current-game))
                    'black
                    'white))
          (loop (cdr hall)
                (and highlight? (not (equal? (car hall) current-game))))))))
  (newline)
  (restore-tty)
  (exit))
